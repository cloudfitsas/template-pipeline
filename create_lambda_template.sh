#!/bin/bash

# Define the project structure
PROJECT_NAME="bancolombia-03-token"
DIRECTORIES=(
  "$PROJECT_NAME/.github/workflows"
  "$PROJECT_NAME/certs"
  "$PROJECT_NAME/src/application/services"
  "$PROJECT_NAME/src/domain/models"
  "$PROJECT_NAME/src/domain/ports"
  "$PROJECT_NAME/src/infrastructure/adapters"
  "$PROJECT_NAME/src/infrastructure/config"
  "$PROJECT_NAME/src/lambda"
)
FILES=(
  "$PROJECT_NAME/.gitignore"
  "$PROJECT_NAME/jest.config.js"
  "$PROJECT_NAME/package.json"
  "$PROJECT_NAME/README.md"
  "$PROJECT_NAME/samconfig.toml"
  "$PROJECT_NAME/template.yaml"
  "$PROJECT_NAME/tsconfig.json"
  "$PROJECT_NAME/.github/workflows/ci.yml"
  "$PROJECT_NAME/src/application/services/LambdaService.ts"
  "$PROJECT_NAME/src/application/services/RequestBodyService.ts"
  "$PROJECT_NAME/src/domain/models/LambdaModel.ts"
  "$PROJECT_NAME/src/domain/ports/LambdaRepository.ts"
  "$PROJECT_NAME/src/infrastructure/adapters/LambdaHttpAdapter.ts"
  "$PROJECT_NAME/src/infrastructure/config/index.ts"
  "$PROJECT_NAME/src/lambda/handler.ts"
)

# Create directories
for dir in "${DIRECTORIES[@]}"; do
  mkdir -p "$dir"
done

# Create files with initial content
cat <<EOL > "$PROJECT_NAME/.gitignore"
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
EOL

cat <<EOL > "$PROJECT_NAME/jest.config.js"
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  transform: {
    '^.+\\\\.tsx?$': 'ts-jest',
  },
  moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
  testPathIgnorePatterns: ['/node_modules/', '/dist/', '/.aws-sam/'],
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  collectCoverageFrom: ['src/**/*.{ts,tsx}', '!src/**/*.d.ts'],
};
EOL

cat <<EOL > "$PROJECT_NAME/package.json"
{
  "name": "02-message-signature",
  "version": "1.0.0",
  "description": "A template for AWS Lambda functions.",
  "main": "dist/lambda/handler.js",
  "scripts": {
    "clean": "rimraf dist .aws-sam",
    "local-sam": "npm run build && sam build && sam local invoke",
    "build": "tsc && npm run copy-certs",
    "copy-certs": "copyfiles certs/**/* dist/",
    "start": "node dist/lambda/handler.js",
    "deploy": "cdk deploy",
    "test": "jest --coverage",
    "sonar": "sonar-scanner"
  },
  "dependencies": {
    "aws-cdk-lib": "^2.177.0",
    "aws-lambda": "^1.0.6",
    "axios": "^0.21.4",
    "constructs": "^10.4.2",
    "node-fetch": "^2.6.1"
  },
  "devDependencies": {
    "@types/aws-lambda": "^8.10.147",
    "@types/jest": "^29.5.14",
    "@types/node": "^14.14.41",
    "@types/node-fetch": "^2.6.12",
    "aws-cdk": "^2.0.0",
    "copyfiles": "^2.4.1",
    "jest": "^29.7.0",
    "rimraf": "^6.0.1",
    "sonarqube-scanner": "^4.2.6",
    "ts-jest": "^29.2.5",
    "typescript": "^4.4.4"
  },
  "engines": {
    "node": ">=14.x"
  },
  "license": "MIT"
}
EOL

cat <<EOL > "$PROJECT_NAME/README.md"
# Lambda Template

This project is a template for creating AWS Lambda functions using TypeScript. It includes a CI/CD pipeline, code coverage, and deployment using AWS SAM.

## Project Structure

- **src/**: Contains the main application code.
  - **application/services/**: Contains service classes that implement business logic.
    - \`LambdaService.ts\`: Service for fetching lambda data.
    - \`RequestBodyService.ts\`: Service for handling request body.
  - **domain/models/**: Contains domain models representing the data structure.
    - \`LambdaModel.ts\`: Model for lambda data.
  - **domain/ports/**: Contains interfaces defining the contracts for repositories.
    - \`LambdaRepository.ts\`: Interface for fetching lambda data.
  - **infrastructure/adapters/**: Contains adapters for external services.
    - \`LambdaHttpAdapter.ts\`: Adapter for making HTTP requests to the lambda endpoint.
  - **infrastructure/config/**: Contains configuration settings.
    - \`index.ts\`: Configuration settings for the service.
  - **lambda/**: Contains the AWS Lambda function handler.
    - \`handler.ts\`: Entry point for the Lambda function.

- **certs/**: Contains SSL certificates for secure communication.
  - \`certificado.pem\`: Public certificate.
  - \`llave.key\`: Private key.

- **.github/workflows/**: Contains the CI/CD pipeline configuration.
  - \`ci.yml\`: GitHub Actions workflow for building, testing, and deploying the Lambda function.

- **package.json**: NPM configuration file listing dependencies and scripts.

- **tsconfig.json**: TypeScript configuration file specifying compiler options.

## Getting Started

1. **Clone the repository**:
   \`\`\`bash
   git clone <repository-url>
   cd lambda-template
   \`\`\`

2. **Install dependencies**:
   \`\`\`bash
   npm install
   \`\`\`

3. **Deploy the Lambda function using AWS CDK**:
   \`\`\`bash
   cd cdk
   cdk deploy
   \`\`\`

## Usage

The service can be invoked via the AWS Lambda function, which will fetch the lambda data from the specified endpoint and return the response.

## License

This project is licensed under the MIT License. See the LICENSE file for details.
EOL

cat <<EOL > "$PROJECT_NAME/samconfig.toml"
version = 0.1
[default.deploy.parameters]
stack_name = "sam-lambda-template"
resolve_s3 = true
s3_prefix = "sam-lambda-template"
region = "us-east-1"
confirm_changeset = true
capabilities = "CAPABILITY_IAM"
disable_rollback = true
image_repositories = []
EOL

cat <<EOL > "$PROJECT_NAME/template.yaml"
AWSTemplateFormatVersion: '2010-09-09'
Transform: 'AWS::Serverless-2016-10-31'
Resources:
  LambdaFunction:
    Type: 'AWS::Serverless::Function'
    Properties:
      FunctionName: 'LambdaFunction'
      Handler: 'dist/lambda/handler.main'
      Runtime: 'nodejs20.x'
      CodeUri: .
      Environment:
        Variables:
          LAMBDA_URL: 'https://example.com/api'
          AUTHORIZATION_HEADER: 'Basic example'
          CERTIFICATE_PATH: './certs/certificado.pem'
          KEY_PATH: './certs/llave.key'
      Policies:
        - AWSLambdaBasicExecutionRole
EOL

cat <<EOL > "$PROJECT_NAME/tsconfig.json"
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "resolveJsonModule": true
  },
  "include": ["src/**/*.ts", "certs"],
  "exclude": ["node_modules", "**/*.spec.ts"]
}
EOL

cat <<EOL > "$PROJECT_NAME/.github/workflows/ci.yml"
name: CI/CD Pipeline

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'

      - name: Install dependencies
        run: npm install

      - name: Build project
        run: npm run build

      - name: Run tests and generate coverage report
        run: npm run test -- --coverage

      - name: Upload coverage report as an artifact
        uses: actions/upload-artifact@v2
        with:
          name: coverage-report
          path: coverage

  deploy:
    runs-on: ubuntu-latest
    needs: build

    steps:
      - name: Checkout code
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'

      - name: Install dependencies
        run: npm install

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: \${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: \${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Deploy with SAM
        run: sam deploy --no-confirm-changeset --stack-name LambdaFunctionSam --capabilities CAPABILITY_IAM
EOL

cat <<EOL > "$PROJECT_NAME/src/application/services/LambdaService.ts"
import { LambdaModel } from '../../domain/models/LambdaModel';
import { LambdaHttpAdapter } from '../../infrastructure/adapters/LambdaHttpAdapter';
import * as jwt from 'jsonwebtoken';

export class LambdaService {
    private readonly lambdaHttpAdapter: LambdaHttpAdapter;

    constructor() {
        this.lambdaHttpAdapter = new LambdaHttpAdapter();
    }

    async fetchLambdaData(requestBody: any): Promise<string> {
        const data: LambdaModel = await this.lambdaHttpAdapter.getLambdaData(requestBody);

        const token = jwt.sign(
            {
                header: {
                    alg: data.header.alg,
                    kid: data.header.kid,
                },
                body: {
                    aud: data.body.aud,
                    exp: data.body.exp,
                    iss: data.body.iss,
                    sub: data.body.sub,
                    jti: data.body.jti,
                    iat: data.body.iat,
                },
            },
            data.signingKeyPEM,
            { algorithm: 'RS256' }
        );

        return token;
    }
}
EOL

cat <<EOL > "$PROJECT_NAME/src/application/services/RequestBodyService.ts"
export class RequestBodyService {
    static getRequestBody(eventBody: string | null, defaultBody: any): any {
        if (eventBody) {
            return JSON.parse(eventBody);
        }
        return defaultBody;
    }
}
EOL

cat <<EOL > "$PROJECT_NAME/src/domain/models/LambdaModel.ts"
export interface LambdaModel {
    header: {
        alg: string;
        kid: string;
    };
    body: {
        aud: string;
        exp: number;
        iss: string;
        sub: string;
        jti: string;
        iat: number;
    };
    signingKeyPEM: string;
}
EOL

cat <<EOL > "$PROJECT_NAME/src/domain/ports/LambdaRepository.ts"
import { LambdaModel } from '../models/LambdaModel';

export interface LambdaRepository {
    getLambdaData(requestBody: any): Promise<LambdaModel>;
}
EOL

cat <<EOL > "$PROJECT_NAME/src/infrastructure/adapters/LambdaHttpAdapter.ts"
import * as https from 'https';
import * as fs from 'fs';
import fetch from 'node-fetch';
import { LambdaModel } from '../../domain/models/LambdaModel';
import { config } from '../config';

export class LambdaHttpAdapter {
    private readonly baseUrl: string;
    private readonly authHeader: string;

    constructor() {
        this.baseUrl = config.LAMBDA_URL;
        this.authHeader = config.AUTHORIZATION_HEADER;
    }

    public async getLambdaData(requestBody: any): Promise<LambdaModel> {
        const certPath = config.CERTIFICATE_PATH;
        const keyPath = config.KEY_PATH;

        if (!fs.existsSync(certPath)) {
            throw new Error(\`Certificate file not found: \${certPath}\`);
        }

        if (!fs.existsSync(keyPath)) {
            throw new Error(\`Key file not found: \${keyPath}\`);
        }

        const cert = fs.readFileSync(certPath, 'utf8');
        const key = fs.readFileSync(keyPath, 'utf8');

        const response = await fetch(this.baseUrl, {
            method: 'POST',
            headers: {
                'Authorization': this.authHeader,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestBody),
            agent: new https.Agent({
                cert: cert,
                key: key,
                rejectUnauthorized: false
            })
        });

        if (!response.ok) {
            throw new Error(\`Error fetching lambda data: \${response.statusText}\`);
        }

        return response.json() as Promise<LambdaModel>;
    }
}
EOL

cat <<EOL > "$PROJECT_NAME/src/infrastructure/config/index.ts"
export const config = {
    LAMBDA_URL: process.env.LAMBDA_URL || 'https://example.com/api',
    AUTHORIZATION_HEADER: process.env.AUTHORIZATION_HEADER || 'Basic example',
    CERTIFICATE_PATH: process.env.CERTIFICATE_PATH || './certs/certificado.pem',
    KEY_PATH: process.env.KEY_PATH || './certs/llave.key'
};
EOL

cat <<EOL > "$PROJECT_NAME/src/lambda/handler.ts"
import { LambdaService } from '../application/services/LambdaService';
import { RequestBodyService } from '../application/services/RequestBodyService';
import { APIGatewayEvent, Context, APIGatewayProxyResult } from 'aws-lambda';

const lambdaService = new LambdaService();

export const main = async (event: APIGatewayEvent, context: Context): Promise<APIGatewayProxyResult> => {
    try {
        const requestBody = RequestBodyService.getRequestBody(event.body, {});
        const data = await lambdaService.fetchLambdaData(requestBody);
        return {
            statusCode: 200,
            body: data,
            headers: {
                'Content-Type': 'application/json',
            },
        };
    } catch (error) {
        return {
            statusCode: 500,
            body: JSON.stringify({ message: 'Error fetching lambda data', error: (error as Error).message }),
            headers: {
                'Content-Type': 'application/json',
            },
        };
    }
};
EOL

echo "Project structure created successfully."